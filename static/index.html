<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Online Stochastic Constraint Satisfaction</title>
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
	  integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w=="
	  crossorigin="anonymous"
	  referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="/ocs.css" />
  <script type="text/javascript" src="/ocs.js"></script>
  <script type="text/javascript" src="/index.js"></script>
</head>
<body>

<h2>Background</h2>
<p><a href="https://berghain.challenges.listenlabs.ai/">Listen Labs</a> recently held
a contest with a problem set to the theme of being a Berghain nightclub bouncer, where
guests arrive with flavored attributes and the player must admit or reject each patron
with the goal of filling the nightclub with 1000 people, while satisfying several lower
bound constraints on the number of patrons with each flavor attribute admitted.</p>
<p>That version was a bit too easy because it considered only static lower bounds, and
the scoring approach (lowest rejection of all attempts) selected for players who submitted
many trials, rather than efficiently identifying high performing algorithms.</p>
<p>Here we introduce a clone of the game with support for more complicated bounds
structures (plus some easy ones to get warmed up on) along with scoring relative to an
offline algorithm's rejection count for the same sequence, allowing successful algorithms
to be identified with significantly fewer trials.</p>

<h2>Problem Statement</h2>
<p>Consider a i.i.d. sequence of random vectors. Each random vector consists of
N binary-valued attributes, which can be represented as a single symbol. The PMF of the
symbols is unknown; instead the marginal probabilities for each attribute and the
correlation matrix between attributes is known, but the joint distribution of all
attributes is not. There are at least two reasonable ways to generate symbols in this
scheme so do not assume a particular generation method.</p>
<p>The objective of the game is to perform online processing of each symbol in a sequence
as it is received, classifying it as accepted or as rejected, such that 1000 symbols are
accepted, a set of scenario-specific constraints is satisfied, and the total sequence
length observed (equivalently, the number of symbols rejected), is minimized.</p>
<p>Each game has a set of known distribution parameters as described above and a set of
constraints, consisting of a relational operator (&gt;= or &lt;) and two arithmetic
expressions combining constants, number of symbols matching an attribute, and basic
operators including addition, subtraction, multiplication, and division. A specific
scenario will use the same parameters each time but will produce a new random sequence.
</p>

<h2>Playing</h2>
<p>Sign up with a display name in order to receive a user UUID, which is how you will
make requests to the game server.</p>
<p id="userinfo" class="indent"></p>
<p>The game operates through HTTP GET requests, with all parameters encoded as GET
arguments and all responses presented as JSON objects. This violates all kinds of design
principles such as GET not requests producing side effects, but it has the benefit of
being extremely simple to interact with and implement as a server. You will make one
GET request to start a game and receive a game UUID, then you will use this UUID to
request new symbols and accept or reject pending symbols.</p>

<h2>Game Status</h2>
<p id="recent_games"></p>

<h2>API</h2>
<p>The basic game API is:</p>

<div class="api_container">
<span class="highlight">/game/new-game?user=<span name="user_uuid"></span>&type=0</span>
 <div class="indent">
  <div>Arguments:
    <div class="indent"><span class="highlight">user</span> uuid of the user playing</div>
    <div class="indent"><span class="highlight">type</span> game type id</div>
  </div>
  <div>Response:
    <div class="indent"><span class="highlight">{"id":"509a80bb-547a-4f55-92ed-815888b85331"}</span></div>
  </div>
  <div>Description:
    <div class="indent">
  This creates a new game of the given type. The game type determines the probability
  distribution used and the goals that must be satisfied. Game types and their parameters
  can be obtained from the <span class="highlight">/game/params</span> route.
    </div>
  </div>
 </div>
</div>

<div class="api_container">
<span class="highlight">/game/process-person?game=df88afc9-b45e-4005-be23-853f34486cc9&person=0&verdict=true</span>
 <div class="indent">
  <div>Arguments:
    <div class="indent"><span class="highlight">game</span> uuid of the game</div>
	<div class="indent"><span class="highlight">person</span> # of person considered</div>
	<div class="indent"><span class="highlight">verdict</span> <b>optional</b>, true to accept this person and false to reject</div>
  </div>
  <div>Response:
    <div class="indent"><span class="highlight">{"status":"running","count":0,"next":0}</span> indicating no symbols have been processed and the next arrival has no attributes</div>
	<div class="indent"><span class="highlight">{"status":"running","count":1,"next":3}</span> indicating one symbol has been processed and the next arrival has attributes 0 and 1 set</div>
	<div class="indent"><span class="highlight">{"status":"completed","count":1546}</span> indicating that 1000 symbols have been accepted (of 1546 total) and all constraints are satisfied</div>
	<div class="indent"><span class="highlight">{"status":"failed","count":1000}</span> indicating that 1000 symbols have been accepted (of 1000 total) but not all constraints were satisfied</div>
  </div>
  <div>Description:
    <div class="indent">
	This either retrieves the next sequence element (when <span class="highlight">verdict
	</span> is omitted) or processes the next sequence element and then retrieves the
	next, next sequence element (when <span class="highlight">verdict</span> is provided)
	</div>
  </div>
 </div>
</div>

<div class="api_container">
<span class="highlight">/game/details?game=509a80bb-547a-4f55-92ed-815888b85331</span>
  <div class="indent">
    <div>Arguments:
	 <div class="indent"><span class="highlight">game</span> uuid or integer id of game</div>
	</div>
	<div>Response:
	  <div class="indent"><span class="highlight">{"count":1000,"accepted":1000,"next":0,"attrs":[365,415,0,0,0,0,0],"type":0,"finished":true,"won":false}</span></div>
	</div>
	<div>Description:
	  <div class="indent">
	  This retrieves summary information about a game including how many symbols
	  have been seen (count), how many were accepted (accepted), what symbol is next if
	  any (next), how many symbols with each attribute (element of attrs) have been
	  accepted, what parameters are used (type), whether the game has ended (finished),
	  and whether the constraints were met (won). The number rejected must be computed
	  from the number seen and the number accepted. Note that this request does not
	  include all of the symbols seen, as that is found in
	  <span class="highlight">/game/symbols</span>, since the complete list of symbols is
	  not needed to show summary info and can be obtained later for a detailed look at a
	  particular game.
	  </div>
	</div>
  </div>
</div>

<div class="api_container">
<span class="highlight">/game/symbols?game=509a80bb-547a-4f55-92ed-815888b85331</span>
  <div class="indent">
    <div>Arguments:
	 <div class="indent"><span class="highlight">game</span> uuid or integer id of game</div>
	</div>
	<div>Response:
	 <div class="indent"><span class="highlight">{"count":1000,"symbols":[131,128,128,128,...,131]}</span></div>
	</div>
	<div>Description:
	  <div class="indent">
	  This retrieves the list of symbols that were seen plus the total expected length of
	  that list. Currently, bits 0-6 encode each of the possible binary variables and
	  bit 7 is set when the symbol was accepted or unset when it was rejected.
	</div>
  </div>
</div>

<div class="api_container">
<span class="highlight">/game/params?type=0</span>
  <div class="indent">
    <div>Arguments:
	 <div class="indent"><span class="highlight">type</span> optional, game type id</div>
	</div>
	<div>Response:
	 <div class="indent"><span class="highlight">{"rulesets":2}</span> when type is omitted</div>
	 <div class="indent"><span class="highlight">{"type":0,"p":[0.361837,0.411532],"Q":[1.000000,0.781522,0.781522,1.000000],"goals":[[8197,4096,600],[8197,4097,600]]}</span> when type is included</div>
	</div>
	<div>Description:
	 <div class="indent">
	 This retrieves game parameters for a specific type of game. p contains the marginal
	 probabilities for each bit that may be set in a particular symbol, and Q is the
	 square correlation matrix between the possible attributes. goals defines the goals
	 as expressions encoded one per array. Each term in a goal is a packed bitfield, with
	 the following convention: bit 13 (8192) indicates that the term is an operator, with
	 the lower order bits identifying the type of operator: 0 for +, 1 for -, 2 for /,
	 3 for *, 4 for &lt;, and 5 for &gt;=; bit 12 (4096) indicates that the term is the
	 current value of an attribute with the lower order bits identifying which one; and
	 values smaller than 4096 encode constants exactly. Each goal is an expression in
	 polish notation. The goal <span class="highlight">[8197, 4096, 600]</span> therefore
	 encodes the expression `&gt;= attr[0] 600` or `attr[0] &gt;= 600` in infix notation.
	 </div>
	 <div class="indent">
	 Currently, p is
	 calculated based on the model used to generate attributes, but Q is measured by
	 generating 10 million symbols and calculating the correlation between each. This
	 means that Q will appear to change between server restarts, but the underlying model
	 will not change! If/when a closed-form solution is obtained for Q that will be used
	 instead.
	 </div>
	</div>
  </div>
</div>

<div class="api_container">
Errors:
  <div class="indent">If an error happens, the response will generatelly be a JSON object
  with a single field named error, such as
  <span class="highlight">{"error":"bad or missing arg type"}</span>. Ideally the error
  message will tell you what you did wrong but this isn't guaranteed. If you're missing a
  GET argument, the name of the argument will be given like in the example. If there was
  a database error it will probably just say 'valkey error' with nothing that can help
  you.
  </div>
</div>

</body>
</html>
